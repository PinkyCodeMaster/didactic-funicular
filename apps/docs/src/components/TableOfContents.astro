---
import type { MarkdownHeading } from 'astro';

export interface Props {
  headings: MarkdownHeading[];
}

const { headings } = Astro.props;

// Filter headings to only include h2 and h3
const tocHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 4);

// Build nested structure
function buildTocTree(headings: MarkdownHeading[]) {
  const tree: any[] = [];
  const stack: any[] = [];

  for (const heading of headings) {
    const item = {
      ...heading,
      children: []
    };

    // Find the correct parent level
    while (stack.length > 0 && stack[stack.length - 1].depth >= heading.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      tree.push(item);
    } else {
      stack[stack.length - 1].children.push(item);
    }

    stack.push(item);
  }

  return tree;
}

const tocTree = buildTocTree(tocHeadings);
---

{tocTree.length > 0 && (
  <nav class="right-sidebar" aria-label="Table of Contents">
    <div class="right-sidebar-content">
      <h2>On this page</h2>
      <ul class="toc-list">
        {tocTree.map((heading) => (
          <li>
            <a href={`#${heading.slug}`} data-depth={heading.depth}>
              {heading.text}
            </a>
            {heading.children.length > 0 && (
              <ul>
                {heading.children.map((child: any) => (
                  <li>
                    <a href={`#${child.slug}`} data-depth={child.depth}>
                      {child.text}
                    </a>
                    {child.children.length > 0 && (
                      <ul>
                        {child.children.map((grandchild: any) => (
                          <li>
                            <a href={`#${grandchild.slug}`} data-depth={grandchild.depth}>
                              {grandchild.text}
                            </a>
                          </li>
                        ))}
                      </ul>
                    )}
                  </li>
                ))}
              </ul>
            )}
          </li>
        ))}
      </ul>
    </div>
  </nav>
)}

<script>
  // Add active state to current heading in viewport
  function updateActiveHeading() {
    const headings = document.querySelectorAll('h2[id], h3[id], h4[id]');
    const tocLinks = document.querySelectorAll('.right-sidebar a[href^="#"]');
    
    let activeHeading = null;
    const scrollPosition = window.scrollY + 100; // Offset for header
    
    // Find the current heading
    for (let i = headings.length - 1; i >= 0; i--) {
      const heading = headings[i] as HTMLElement;
      if (heading.offsetTop <= scrollPosition) {
        activeHeading = heading;
        break;
      }
    }
    
    // Update active states
    tocLinks.forEach(link => {
      const href = (link as HTMLAnchorElement).getAttribute('href');
      if (href === `#${activeHeading?.id}`) {
        link.setAttribute('aria-current', 'true');
      } else {
        link.removeAttribute('aria-current');
      }
    });
  }
  
  // Smooth scroll for TOC links
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = document.querySelectorAll('.right-sidebar a[href^="#"]');
    
    tocLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const href = (link as HTMLAnchorElement).getAttribute('href');
        const target = document.querySelector(href!);
        
        if (target) {
          const headerHeight = 80; // Approximate header height
          const targetPosition = (target as HTMLElement).offsetTop - headerHeight;
          
          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
          });
          
          // Update URL without triggering scroll
          history.pushState(null, '', href);
        }
      });
    });
    
    // Initial active heading update
    updateActiveHeading();
    
    // Update on scroll
    let ticking = false;
    window.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          updateActiveHeading();
          ticking = false;
        });
        ticking = true;
      }
    });
  });
</script>

<style>
  .right-sidebar {
    position: sticky;
    top: var(--sl-nav-height, 4rem);
    height: calc(100vh - var(--sl-nav-height, 4rem));
    overflow-y: auto;
    padding: 1.5rem;
    background: var(--sl-color-gray-1);
    border-left: 1px solid var(--sl-color-gray-3);
    width: 250px;
    flex-shrink: 0;
    font-size: 0.875rem;
  }
  
  .right-sidebar h2 {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--sl-color-gray-6);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin: 0 0 1rem 0;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--sl-color-gray-3);
  }
  
  .toc-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }
  
  .toc-list li {
    margin: 0;
  }
  
  .toc-list a {
    display: block;
    padding: 0.5rem 1rem;
    color: var(--sl-color-gray-6);
    text-decoration: none;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
    font-weight: 500;
    line-height: 1.4;
    border-left: 3px solid transparent;
  }
  
  .toc-list a:hover {
    background: var(--sl-color-gray-2);
    color: var(--oakford-primary, #2563eb);
    border-left-color: var(--oakford-primary, #2563eb);
    transform: translateX(2px);
  }
  
  .toc-list a[aria-current="true"] {
    background: var(--oakford-primary, #2563eb);
    color: white;
    font-weight: 600;
    border-left-color: var(--oakford-primary-dark, #1d4ed8);
  }
  
  /* Nested lists */
  .toc-list ul {
    margin-left: 1rem;
    border-left: 1px solid var(--sl-color-gray-3);
    padding-left: 0.5rem;
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
  }
  
  .toc-list ul a {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    color: var(--sl-color-gray-5);
  }
  
  /* Dark mode */
  :root[data-theme='dark'] .right-sidebar {
    background: var(--sl-color-gray-2);
    border-left-color: var(--sl-color-gray-4);
  }
  
  :root[data-theme='dark'] .right-sidebar h2 {
    color: var(--sl-color-gray-5);
    border-bottom-color: var(--sl-color-gray-4);
  }
  
  :root[data-theme='dark'] .toc-list a:hover {
    background: var(--sl-color-gray-1);
    color: var(--oakford-primary-light, #60a5fa);
  }
  
  :root[data-theme='dark'] .toc-list ul {
    border-left-color: var(--sl-color-gray-4);
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .right-sidebar {
      display: none;
    }
  }
  
  @media (min-width: 1024px) {
    .right-sidebar {
      width: 280px;
    }
  }
</style>